
/*******************/
// ObjectPool.cpp
#include "ObjectPool.h"


/*******************/
// ObjectPool.h
#pragma once
#include <vector>
#include <iostream>

template<typename T>
class DefaultAllocator {
public:
	T* operator()() {
		return new T{};
	}
	void operator()(T* p) {
		delete p;
	}
	void Reset() {

	}
};

template<
	typename T,
	size_t max_size = std::numeric_limits<size_t>::max(),  // value parameter with default
	typename AllocatorT = DefaultAllocator<T>>  // type parameter with default
class ObjectPool
{
	struct ObjectInfo {
		bool m_IsUsed{};
		T* m_pObject{};
	};
	inline static std::vector<ObjectInfo> m_PooledObjects{};
	inline static AllocatorT m_Allocator{};
public:
	[[nodiscard("Object will remain unused")]]  // c++17 attribute
	static T* Acquire() {
		for (auto& obj : m_PooledObjects) {
			if (!obj.m_IsUsed) {
				obj.m_IsUsed = true;
				std::cout << "[POOL] Returning an existing object\n";
				return obj.m_pObject;
			}
		}
		if (m_PooledObjects.size() == max_size) {
			std::cout << "Pool is full!\n";
			return nullptr;
		}
		std::cout << "[POOL] Creating a new object\n";
		auto pObj = m_Allocator();  // T* operator()(
		m_PooledObjects.push_back({ true,pObj });
		return pObj;
	}
	static void Release(const T* pObj) {
		for (auto& obj : m_PooledObjects) {
			if (obj.m_pObject == pObj) {
				obj.m_IsUsed = false;
				break;
			}
		}
	}
	static void Destroy() {
		for (auto& obj : m_PooledObjects) {
			if (obj.m_IsUsed) {
				std::cout << "WARNING! Deleting an object still in use\n";
			}
			m_Allocator(obj.m_pObject);  // operator()(T* p)
		}
		m_Allocator.Reset();
		m_PooledObjects.clear();
	}
};



/*******************/
// main.cpp

#include <iostream>
#include "ObjectPool.h"

class Test {
    Test() {
        std::cout << "Test constructor\n";
    }

public:
    void Foo() {
        std::cout << "Test::Foo()\n";
    }

    friend class TestAllocator;  // Because of Test has a private constructor
};

class TestAllocator {
public:
    Test* operator()() {
        std::cout << "TestAllocator::Create()\n";
        return new Test{};
    }

    void operator()(Test* p) {
        std::cout << "TestAllocator::Destroy()\n";
        delete p;
    }

    void Reset() {
        std::cout << "TestAllocator::Reset()\n";
    }
};

// ------------------------ Main ------------------------
int main() {
    std::cout << "=== Using ObjectPool<int> ===\n";
    using IntPool = ObjectPool<int, 3>; // Default allocator <-- it is here where the private static vector is created

    auto p1 = IntPool::Acquire(); // new
    auto p2 = IntPool::Acquire(); // new
    auto p3 = IntPool::Acquire(); // new

    auto p4 = IntPool::Acquire(); // pool full -> nullptr
    IntPool::Release(p1);         // free p1
    auto p5 = IntPool::Acquire(); // reuse p1
    IntPool::Destroy();           // free all

    std::cout << "\n=== Using ObjectPool<Test, 2, TestAllocator> ===\n";
    using TestPool = ObjectPool<Test, 2, TestAllocator>;

    Test* t1 = TestPool::Acquire(); // create new Test
    Test* t2 = TestPool::Acquire(); // create new Test
    Test* t3 = TestPool::Acquire(); // pool full -> nullptr

    if (t1) t1->Foo();
    TestPool::Release(t1);
    Test* t4 = TestPool::Acquire(); // reuse t1
    TestPool::Destroy();           // free all
}

// m_PooledObjects for int and Test live in separate pools.
// Each type has its own isolated pool (correct for this design).
// Int and Test objects do not share the static array.
